---
title: 无损文件压缩
date: 2018-10-09 20:09:35
tags:
- 压缩
- 哈夫曼
- LZ77
---

>emmmmmmmmm……
>突然发现半年前挖的坑……
>```
>write date: 2019-4-5
>```
>emmmmmmmmm……

无损压缩（下简称"压缩"）是计算机存储方面很重要的一种课题（至少在过去是），这是一种典型的时间换空间的方案。

过去由于存储介质普遍很贵，所以压缩方式存储文件可以更大化的利用存储介质的空间（就问你有没有见过只有40G的PC硬盘，想想都可怕）。

压缩，顾名思义就是把大文件的体积变小，让他在存储的时候能够少用一点存储空间，而且压缩后的文件能保证可以反向解算出来并且内容不会变化，但是压缩后的文件不能直接被文件系统识别和读取，需要先对文件进行解压之后才能读取其中内容，解压的时候会消耗一定时间，所以说是时间换空间。

压缩存储其实也就是对文件进行了特殊编码然后存储，今天主要介绍两种压缩编码：哈夫曼编码、LZ77编码。

### 哈夫曼编码

哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种，是一种用于无损数据压缩的熵编码（权编码）算法。由美国计算机科学家大卫·霍夫曼（David Albert Huffman）在1952年发明。

这里我们先不管这个什么熵编码是啥意思，哈夫曼编码的核心是统计学原理。
简单举个例子，一篇英文文稿，也就是由a～z一共26种英文字母组成，而且有的字母出现频率很高，有些则很低。这时候我们就可以把频繁出现的部分替换为短一点的数据存储。比如如果字母e出现的频率很高，那么我们就用 bit: 0 表示字母e，这样所有有字母e的位置存储的大小都有 1 byte 变为了 1 bit，直接把字母e压缩了87.5%。其他的字母如果还有出现频次比较高的，也按照这个思路压缩，依次使用 bit: 1、bits: 00、bits: 01……这样向后不断填写替换原先的数据，这其实就是哈夫曼编码的核心思想。

所以说哈夫曼编码中我们需要预先知道所有要编码内容的出现频率，这里我们方便讨论，文件中按照字节看，也就是0～255一共256种可能字节，我们就以这256种字节作为编码对象简述一下过程：
>1、读取源文件，统计这256种字节每一种出现的频数。
>2、把统计得到的结果按照频数排序。
>3、自底向上按照频数建立一个哈夫曼树。
>4、根据树节点输出哈夫曼表。
>5、按照哈夫曼表中的对应关系对数据重新进行编码并存储。
>6、存储哈夫曼树/表信息用于解码。

这之中的重点就是哈夫曼树/表，下面通过对以上过程的详解穿插介绍一下这个树/表的来历。

#### 哈夫曼编码过程

如果我们现在要压缩的数据是：
```
ABBCDADDE
```
统计这份数据各个字节出现的频数：
```
A B C D E
2 2 1 3 1
```
把数据按照频数排序：
```
C E A B D
1 1 2 2 3
```
下面就是建立哈夫曼树了。
我们先选择出现频数最低的两个节点（C，E），然后把它们放在同一个父节点下，父节点记录这两个节点一共出现的频数：
[![ZIP1](/img/Compression/1.png)](/img/Compression/1.png)
然后把他们的父节点与剩余的频数分布放到一起并排序（剔除C、E之后剩余的频数分布节点）
```
A B *(2) D
2 2  2   3
```
这里为什么把它放在A、B之后一会儿做说明。
然后又回到了排序好的状态，重复挑选最低频数过程，直到这个频数分布表只剩下一个节点。
```
*(9)
 9
```
最终我们得到这样一个树：
[![ZIP1](/img/Compression/2.png)](/img/Compression/2.png)
得到这棵树之后我们这样建立哈夫曼表：
**先序遍历这棵树，然后记录路径，每向左一次记一个 0，向右一次记一个 1。**
举个例子：
从根节点到E节点，我们的路径是“右左右”，所以E对应的编码是“101”
按照这种方法我们得到的哈夫曼表如下：

|  Node | Code |
|-------|------|
|   A   |  00  |
|   B   |  01  |
|   C   | 100  |
|   D   |  11  |
|   E   | 101  |

*以上的1、0都是bit表示*
*所以这里你也可以思考一下，如果把新节点排序放在前面建立的树形态，这样你就理解为什么我们要把新节点放到后面了。*

使用这些编码我们对原数据进行编码，对比原数据：
```
压缩后：
    0001 0110 0110 0111 1101
=>  0x1667D
    2.5 bytes
原数据：
    ABBCDADDE
=>  0x414242434441444445
    9 bytes
```
这样我们就把数据由原来的9字节压缩成了2.5字节。
把编码的数据重新存储，并且存储树信息，这样完整的哈夫曼编码过程就结束了。

#### 哈夫曼解码过程
有编码肯定要有解码，解码失败那我们数据等于白存了。
哈夫曼的解码过程比较简单，还举刚刚的例子，假设我们已经拿到了编码和哈夫曼树。
由于编码是：
```
0x1667D => 0001 0110 0110 0111 1101
```
树参考刚刚的图，这里不再赘述。
我们按照编码时候的方式对数据进行展开，具体操作：
**根据树信息和编码，从根结点开始，如果编码是0，去当前节点的的左子树，否则去右子树，如果新节点是一个叶子结点，那么就把数据输出然后退回根结点，重复这个过程直到数据结束。**
比如我们按顺序读到了0，去往左子树，该点不是叶子，继续读又读到了0，继续前往左子树，这时候我们就到了节点A，输出A，然后退回根结点继续按照刚刚的方式读，一直到最后我们就得到了完整的原数据：ABBCDADDE。

哈夫曼编码的主要内容就是以上这些。

### LZ77编码

