---
title: 有限集内MD5/SHA1可逆吗？——MD5、SHA1算法(施工中)
date: 2018-10-03 08:36:05
tags:
- hash算法
- MD5
- SHA1
- 矩阵
---

<link rel="stylesheet" href="http://cdn.bootcss.com/highlight.js/9.12.0/styles/vs2015.min.css"/>
<script src="http://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>  

今天讲一讲hash算法。

hash算法不可逆，大家都知道，因为这是一个一对多的问题，一个MD5/SHA1值理论上是可以对应多个原始数据的，所以MD5/SHA1是无法还原出原始信息的。

但是，如果我指定范围，你能通过MD5/SHA1倒推出原始数据吗？

举个例子：定义一个hash算法，取值在255下的模，这样的hash值也是不能直接反推数据的，但是如果我说我数据就是在1～255之间的值，那我给定一个hash值，无疑你是能得到原始数据的。

但是MD5/SHA1呢？

这里容我先卖个关子，今天主要是先介绍MD5/SHA1算法，最后我们会讨论这个问题。

### 散列算法

在了解MD5、SHA1之前，我们先了解一下什么是散列算法。

散列算法，或者叫哈希函数，主要是一种通过计算得出数据特征值的算法，算法主要是在字典结构中使用，通过哈希算法算得数据的哈希值可以快速查找数据是否存在或者提取数据。

后来人们发现，这些特征值其实也是数据的一种特有性质或者属性，而且当你的算法比较完备的时候，不同数据的特征值几乎不可能存在重复的，就跟人的指纹一样，指纹可能会有相似的，但是指纹到目前为止还可以作为重要的断案依据。所以，为什么不使用散列算法为这些数据建立特征值呢？于是便诞生了安全领域的散列算法，又叫做安全散列算法。

安全领域的散列算法主要就是通过一些比较快的处理方式，可以快速计算出数据的哈希值，然后使用该值进行数据确认，安全传输确认等工作。

举个简单的例子：一个用户在某个网站下载了一个软件的安装镜像文件，他为了确认这个软件的安装程序是否是真的安装镜像，防止是伪造的病毒或者特洛伊木马，他就可以去访问软件官网确认一下安装包的镜像MD5值是多少，然后跟下载回来的镜像MD5值做比对（大部分软件巨头的软件都提供他们的镜像MD5校验），如果MD5值不同就说明被动过手脚。如果还不放心他可以继续比对二者的SHA1、SHA-256之类的哈希值。

安全的散列算法现在已经广泛应用于安全登录、安全认证、安全访问等领域，它与加密算法不同，只提供数据特征值，过程单向，大部分情况推出原始数据是不可能的……好像绕回来了。总之先不管这些，散列算法大部分都是不可逆的。

但是它跟加密算法又有千丝万缕的联系，有些甚至是加密算法的一个子集，通过加密算法修改几个步骤、添加一些输出它就摇身一变变成了散列算法。

所以我苦苦追查了好久MD5/SHA1的历史由来，到底是怎么发展来的，换一种说法是当时是从什么加密算法变种设计而来的，很遗憾的是算法的真正发展历史已经不可考，只知道MD5经历过MD2->MD3->MD4->MD5几个阶段，SHA1则是在MD5的基础上修改而来，其他的信息少的可怜，已经不知道发明这算法的人当初是怎么把它们设计出来的了……

当下流行的安全领域散列算法主要是两个派系：MD2/3/4/5系列和SHA系列，接下来主要介绍两者的主要代表：MD5和SHA1。

### MD5算法

如上面所说MD5算法经历了怎样的设计目前已经不可考，所以下面直接说明MD5的算法流程：

MD5首先定义了如下几个函数：

```c
int32_t F(a, b, c) { return (a & b) | ((~a) & c); }
int32_t G(a, b, c) { return (a & c) | (b & (~c)); }
int32_t H(a, b, c) { return a ^ b ^ c; }
int32_t I(a, b, c) { return b ^ (a | (~c)); }

& 按位与
| 按位或
^ 按位异或
~ 取补码
```

由这四个函数延伸出如下几个函数：

```c
void FF(a, b, c, d, M, s, t) { a = b + (a + F(b, c, d) + M + t) << s; }
void GG(a, b, c, d, M, s, t) { a = b + (a + G(b, c, d) + M + t) << s; }
void HH(a, b, c, d, M, s, t) { a = b + (a + H(b, c, d) + M + t) << s; }
void II(a, b, c, d, M, s, t) { a = b + (a + I(b, c, d) + M + t) << s; }

<< 循环左移，举例：0x01001100 << 5 = 0x10001001
```

MD5在开始处理数据之前会先对数据进行补齐，使数据变成 N * 512 + 448 bits 的形式。如果数据原始长度在512上的模刚好是448也需要补齐，补齐方法是在原始数据后面跟上一位1和若干个0，举例：

```c
原始数据：0x7AD2 
二进制：0x01111011 11010010
原数据长度：16 bits
需补齐长度：448 - 16 = 432

补齐之后：0x7AD28000 0x00000000 ...省略12个0x00000000
二进制：0x01111011 11010010 10000000 00000000 ...省略416个0
```

算法的初始状态MD5定义了四个幻数：
```c
A = 0x01234567
B = 0x89ABCDEF
C = 0xFEDCBA98
D = 0x76543210
```

幻数以小端字节序存储（内存地址由低到高）
而变成中我们的变量存储方式是大端字节序（内存地址从高到低）
所以编程时我们定义的幻数应该是：
```c
A = 0x67452301
B = 0xEFCDAB89
C = 0x98BADCFE
D = 0x10325476
```

数据处理按照块进行，每块大小为512 bits（64 bytes）。
这里你会发现如果按照刚刚的补齐，数据原始长度在512的模不是0，缺少的64 bits 怎么办？这里并不是MD5把这64 bits 忘记了，而是定义了他们的特殊作用。MD5最后64 bits的作用是存储原始数据长度，长度也是以小端字节序存储。
最后64 bits处理举例：
```c
原始数据为字符串“abc”，长度为24 bits（3 bytes）
最后64 bits 为：0x18000000 00000000

原始数据为264 bits（33 bytes）
最后64 bits 为：0x08010000 00000000

原始数据长度超过64 bits 可存储的大小取齐低64位。
换一种说法就是按照长度的小端字节序存储，存满为止。
```

数据和初始幻数定义完毕之后，下面就是对数据的处理。
MD5对每块数据做4轮处理，每轮进行16次运算，每轮都将数据分为16个分组，每组32 bits（4 bytes），每块数据处理开始时继承上一轮处理完毕之后的A、B、C、D作为初始值，最开始的一块数据使用的就是4个初始幻数。
假设M[j]表示第i个分组的数据，每轮的操作如下：
```c
// 第一轮
for (i = 0; i < 16; i++) {
    switch (i % 4) {
        case 0:
            FF(A, B, C, D, M[i], 7, t[i]);
            break;
        case 1:
            FF(D, A, B, C, M[i], 12, t[i]);
            break;
        case 2:
            FF(C, D, A, B, M[i], 17, t[i]);
            break;
        case 3:
            FF(B, C, D, A, M[i], 22, t[i]);
            break;
    }
}
// 第二轮
for (i = 0; i < 16; i++) {
    switch (i % 4) {
        case 0:
            GG(A, B, C, D, M[i * 5 + 1] % 16, 5, t[i + 16]);
            break;
        case 1:
            GG(D, A, B, C, M[i * 5 + 1] % 16, 9, t[i + 16]);
            break;
        case 2:
            GG(C, D, A, B, M[i * 5 + 1] % 16, 14, t[i + 16]);
            break;
        case 3:
            GG(B, C, D, A, M[i * 5 + 1] % 16, 20, t[i + 16]);
            break;
    }
}
// 第三轮
for (i = 0; i < 16; i++) {
    switch (i % 4) {
        case 0:
            HH(A, B, C, D, M[(i * 3 + 5) % 16], 4, t[i + 32]);
            break;
        case 1:
            HH(D, A, B, C, M[(i * 3 + 5) % 16], 11, t[i + 32]);
            break;
        case 2:
            HH(C, D, A, B, M[(i * 3 + 5) % 16], 16, t[i + 32]);
            break;
        case 3:
            HH(B, C, D, A, M[(i * 3 + 5) % 16], 23, t[i + 32]);
            break;
    }
}
// 第四轮
for (i = 0; i < 16; i++) {
    switch (i % 4) {
        case 0:
            II(A, B, C, D, M[i * 7 % 16], 6, t[i + 48]);
            break;
        case 1:
            II(D, A, B, C, M[i * 7 % 16], 10, t[i + 48]);
            break;
        case 2:
            II(C, D, A, B, M[i * 7 % 16], 15, t[i + 48]);
            break;
        case 3:
            II(B, C, D, A, M[i * 7 % 16], 21, t[i + 48]);
            break;
    }
}
```

别忙，我知道你肯定会问这个t[i]是个什么鬼东西。
MD5中对t[i]的定义是：
```c
t[i] = (int32_t)(2^32 * abs(sin(i + 1)));
```

### SHA1算法

### 有限集可逆？

### 写到最后

MD5在实现中要确认大小端排序，这个跟普通变成思路有点不太一样，需要时刻注意，SHA1则没有这个要求。