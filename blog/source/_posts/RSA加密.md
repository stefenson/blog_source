---
title: RSA加密
date: 2018-02-24 00:16:46
tags:
- 加密
- RSA
- 中国剩余定理
- 欧拉定理
- 欧拉函数
- 数论
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

---------------------
>大家新年好呀！新的一年祝大家事业顺利，合家欢乐！
>新年刚过去，不知道大家都受了多少红包呀？
>反正我是没有了，555555
>算了，不说这些有的没的了，年后的打算中，我计划把以前我记在本子上的东西全部搬运到博客中来，工作量会有点大，本人也不是那么勤奋，但是我会尽量写下去的。

---------------------

今天主要介绍的是RSA加密。

RSA加密是目前世界上最流行的非对称加密，它名字的来源于它的三位父亲：罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman），他们在1977年提出了RSA加密并且在1987年7月首次在美国公布，RSA来源于他们的姓氏开头字母。

RSA加密内容其实很简单，先给出RSA加密的步骤
1. 寻找两个质数\\(p\\)、\\(q\\)（尽量大一点）。
2. 令\\(n=pq,\;\phi(n)=(p-1)(q-1)\\) 。
3. 找一个数\\(e\\)，使得\\(e\\)与\\(\phi(n)\\)互质。
4. 找一个数\\(d\\)，使得\\(de\;\%\;\phi(n)=1\\)。

以上步骤得出了RSA的一组公钥和私钥，公钥为\\((e, n)\\)，私钥为\\((d, n)\\)。
如果原始数据为\\(D\\)，则加密数据\\(S\\)的计算方法为：
$$S=D^e\;\%\;n$$
解密数据的计算公式为：
$$D=S^d\;\%\;n$$
>*PS：RSA加密要求 \\(D<n\\)，因为根据算法过程可知，最终解密时，解密得到的结果为 \\(n\\)的余数，余数不可能比 \\(n\\)大，所以 \\(D<n\\)。*

是不是很简单？

###### *如果你只是寻找RSA加密的方法结论，那么以上内容就是全部了，下面的就不用看了233。*

从这个过程中也可以看出这里非对称加密的意思，普通的加密中，加密方和解密方都是用的同一个加密钥匙，但是RSA中二者的钥匙却不一样。
是不是很神奇？

可能你会想：“WTF，为什么会有这种神奇的算法？”，下面我们就从RSA加密基础的地方一点一点讲解这个算法的来历。

### 模运算基础
首先介绍一下什么是模运算。
模运算是数论中引入的一个概念，表示该数在所给的数字范围内的一个特征值。
这个特征值计算方法就是除以所给的数计算余数。
所以说，模运算其实就是余数，不过在数论中起了一个高大上的名字而已。
它的表示方法，这里我只介绍我用的比较多的方法：
$$x\equiv a\;(mod\;n)$$
该式子表示\\(x\\)除以\\(n\\)的余数为\\(a\\)，相当于\\(x\;\%\;n=a\\)。
模运算有下面这些性质：
- 如果\\(a\equiv b\;(mod\;n)\\)，则\\(b\equiv a\;(mod\;n)\\)
- 如果\\(a\equiv b\;(mod\;n)\\)，则\\(a + kn\equiv b\;(mod\;n)\\)
- 如果\\(a\equiv b\;(mod\;n)\\)，\\(b\equiv c\;(mod\;n)\\)，则\\(a\equiv c\;(mod\;n)\\)
- 如果\\(a\equiv b\;(mod\;n)\\)，则\\(ax\equiv bx\;(mod\;n)\\)
- 如果\\(a\equiv b\;(mod\;n)\\)，\\(c\equiv d\;(mod\;n)\\)，则\\(a\pm c\equiv b\pm d\;(mod\;n)\\)
- 如果\\(a\equiv b\;(mod\;n)\\)，\\(n=m_1 m_2 ... m_n\\)，则\\(a\equiv b\;(mod\;m_1)\\)，\\(a\equiv b\;(mod\;m_2)...a\equiv b\;(mod\;m_n)\\)

其实还有很多性质，这里就不再一一列举。
上面这些性质证明过程都比较简单，这里简单说一下证明思路：\\(a\equiv b\;(mod\;n)\\)换一种表达方式就是\\(a=kn + b\\)，通过这个转换这些性质都能够得到证明。

模运算是RSA证明过程的基石，这个必须了解。

### 扩展欧几里得算法
欧几里得算法即辗转相除法，求两个数最大公约数的算法，这里记求两数最大公约数的函数为\\(gcd(x, y)\\)。
扩展欧几里得算法描述为：两个整数\\(a, b\\)，必存在参数\\(x, y\\)使得\\(ax + by = gcd(a, b)\\)。

扩展欧几里得算法其实就是欧几里得算法的逆过程，举例\\(37\\)和\\(23\\)：
>\\(\begin{align} 37&=23\*1+14 \\\ 23&=14\*1+9 \\\ 14&=9\*1+5 \\\ 9&=5\*1+4 \\\ 5&=4\*1+1 \\\ 4&=1\*4 \end{align}\\)

反推：
>\\(\begin{align} 1&=5-4 \\\&=5+5-9 \\\&=2\*(14-9)-9 \\\&=2\*14-3\*(23-14) \\\&=5\*(37-23)-3\*23  \\\&=5\*37-8\*23 \end{align}\\)

每一个欧几里得算法计算过程都能如此反推，所以扩展欧几里得算法成立。

扩展欧几里得算法主要用于证明模逆元的存在必然性，需要了解一下。

### 模逆元/模倒数
整数\\(a\\)在模\\(n\\)上的逆元\\(b\\)定义如下：
$$ab\equiv 1\;(mod\;n)$$
其中\\(a\\)与\\(n\\)互质，否则\\(b\\)不存在。
证明：
- 由扩展欧几里得算法，有\\(ax+ny=gcd(a,n)\\)。
- 如果\\(a\\)与\\(n\\)互质，则\\(gcd(a,n)=1\\)，所以\\(ax+ny=1\\)。
- 在模\\(n\\)上，\\(ax+ny\equiv ax\equiv 1\;(mod\;n)\\)，则由定义可知，\\(x\\)即为\\(a\\)在模\\(n\\)上的逆元。
- 如果\\(a\\)与\\(n\\)不互质，则\\(gcd(a,n)=r\\)，\\(ax+ny=r\\)。
- 同样在模\\(n\\)上，\\(ax+ny\equiv ax\equiv r\;(mod\;n)\\)，由于\\(r\neq 1\\)，所以在整数范围内无论\\(x\\)怎么取都不会使\\(ax\equiv 1\;(mod\;n)\\)成立。

由以上过程可知，\\(a\\)与\\(n\\)互质是\\(a\\)在模\\(n\\)上存在逆元的充要条件。

模逆元会存在多个，假如\\(a\\)在模\\(n\\)的一个逆元为\\(a^{-1}\\)，那么所有\\(a\\)在模\\(n\\)的逆元可用如下通式计算：
$$a^{-1}_k = a^{-1} + kn$$
证明很简单：如果\\(a·a^{-1}\equiv 1\;(mod\;n)\\)，则由\\(a(a^{-1}+kn)=a·a^{-1}+akn\\)可得\\(a(a^{-1}+kn)\equiv a·a^{-1}+akn\equiv a·a^{-1}\equiv 1\;(mod\;n)\\)，所以\\(a^{-1}_k = a^{-1} + kn\\)为\\(a\\)在模\\(n\\)的逆元通解。

这个概念在后面中国剩余定理和欧拉定理里面都有涉及，简单了解一下。


